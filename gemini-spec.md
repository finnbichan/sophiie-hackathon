# meetingmAIte: Gemini Agent Specification

This document outlines the steps for an AI coding agent to build the meetingmAIte desktop application.

## Project Overview

meetingmAIte is a desktop application that enhances the Google Meet experience. It wraps a Google Meet call in a webview and provides AI-powered features, including real-time transcription, meeting analysis, and interactive agent assistance.

## Technology Stack

*   **Desktop App Framework:** Electron
*   **Frontend:** React with TypeScript
*   **Styling:** A CSS framework like Tailwind CSS or Material-UI for a modern look and feel.
*   **Real-time Transcription:** A suitable speech-to-text API (e.g., Google Cloud Speech-to-Text, Deepgram).
*   **AI Agent:** A powerful large language model (e.g., Gemini).

## Development Steps

### 1. Project Setup

1.  Initialize a new Electron project with React and TypeScript.
2.  Set up the basic project structure with folders for `src`, `components`, `pages`, `services`, etc.
3.  Configure the build process (e.g., using webpack or Vite) to compile the React code and package the Electron app.

### 2. Landing Page

1.  Create a `LandingPage` React component.
2.  Implement a text input field for the Google Meet link.
3.  Add a text area for users to provide meeting context.
4.  Implement a file upload button for context files.
5.  Create a "Join Call" button.
6.  Implement routing to navigate to the `CallPage` when the "Join Call" button is clicked, passing the Meet link and context.

### 3. Call Page

1.  Create a `CallPage` React component with a four-quadrant layout.
2.  **Call Window (Left Side):**
    *   Implement an Electron `webview` to load the Google Meet URL.
    *   Ensure the user can interact with the Meet call (audio, video, chat, etc.).
3.  **Transcript Window (Top Right):**
    *   Create a `TranscriptWindow` component.
    *   Set up the real-time transcription service. This will involve:
        *   Capturing audio from the system or browser.
        *   Sending the audio stream to the speech-to-text API.
        *   Receiving the transcript and speaker identification in real-time.
    *   Display the scrolling transcript with speaker labels.
4.  **Action Window (Middle Right):**
    *   Create an `ActionWindow` component.
    *   This window will display suggestions from the AI agent.
    *   The AI agent will analyze the transcript and suggest actions like:
        *   "Should I ask about X?"
        *   "Reminder: Follow up on Y." (with "Approve/Deny" buttons)
        *   Relevant context from the uploaded documents.
5.  **Interaction Window (Bottom Right):**
    *   Create an `InteractionWindow` component.
    *   Implement a chat interface (text input and message display area).
    *   This allows the user to interact with the AI sub-agent.
6.  **"Whisper" Mode:**
    *   Implement a global hotkey listener for the "p" key.
    *   When "p" is pressed:
        *   Mute the user in the Google Meet call.
        *   Start voice dictation, populating the **Interaction Window**'s input box.
    *   When "p" is released:
        *   Stop dictation.
        *   Submit the dictated text to the AI sub-agent.
        *   Unmute the user in the Google Meet call.
7.  **End of Call:**
    *   Detect when the Google Meet call has ended.
    *   Navigate to the `EndOfCallPage`.

### 4. End of Call Page

1.  Create an `EndOfCallPage` React component.
2.  Display a summary of the meeting, generated by the AI agent.
3.  Show a list of actions taken during the call (e.g., reminders set).
4.  Include an interaction window for follow-up questions to the agent.
5.  Add a "Finish" button that navigates back to the `LandingPage`.

### 5. AI Agent Integration

1.  Create a service to communicate with the Gemini API.
2.  The agent will need to:
    *   Process the real-time transcript.
    *   Analyze the transcript for action items, questions, and key topics.
    *   Incorporate the user-provided context.
    *   Generate suggestions for the **Action Window**.
    *   Respond to user queries in the **Interaction Window**.
    *   Generate the end-of-call summary.

### 6. Packaging and Distribution

1.  Configure `electron-builder` or a similar tool to package the application for different operating systems (Windows, macOS, Linux).
2.  Create an installer and an executable file.
